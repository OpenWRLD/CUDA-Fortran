
module dev
  
  use cudafor
  
  implicit none
  
  ! With PGI 17.4, still the pointers must be only declared at the module scope
  integer, dimension(:), allocatable, device, target :: d_a ! array on the device
  integer, dimension(:), allocatable, target :: d_b
  integer, dimension(:), allocatable, managed :: d_mng_c
  integer, dimension(:), pointer, texture :: d_ptr_tex
    
  contains
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  attributes(global) subroutine device_sets_on_device(a, val)
    integer, intent(inout) :: a(:)
    integer, intent(in), value :: val
    
    a = val
    
  end subroutine device_sets_on_device
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  attributes(global) subroutine device_gets_from_device(a, val)
    integer, intent(in) :: a(:)
    integer, value :: val
    
    val = a(1)
     
  end subroutine device_gets_from_device
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  attributes(global) subroutine get_tex_value(host_arr, n)
    integer, intent(inout), dimension(:) :: host_arr
    integer, intent(in), value :: n
    
    integer :: i
    
    i = threadidx%x + blockdim%x * (blockidx%x - 1)
    
    if (i <= n) then 
       host_arr(i) = d_ptr_tex(i) 
    endif
    
  end subroutine get_tex_value
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  
end module dev



module host

  use dev
  
  implicit none

  integer, parameter :: n = 1
  integer :: ierr
  
  contains 
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  subroutine ping_dev_ptr_2_host_targ()
    integer, dimension(:), allocatable, device, target :: h_a ! array on the host
    integer, dimension(:), device, pointer :: d_ptr_a
    integer :: jerr
    integer :: send, receive
    
    print '(a)', 'ping_dev_ptr_2_host_targ:'
    
    ! allocate the host array, and let the device pointer point to it
    if (allocated(h_a)) deallocate(h_a) 
    allocate(h_a(n), stat=ierr)
    if (ierr /= 0) stop 'host allocation failed for h_a'
    if (associated(d_ptr_a)) nullify(d_ptr_a) 
    
    d_ptr_a => h_a

    send = +1
    call device_sets_on_device<<<1,1>>>(d_ptr_a, send)
    call device_gets_from_device<<<1,1>>>(d_ptr_a, receive)
    
    if (receive == send) then
      print '(a)', 'OK: host can send to and receive from a device pointer'
    else
      print '(a)', 'Failed: host cannot send/receive with a device pointer'
      print '(2(a,1x,i12))', 'sent: ', send, ', and received: ', receive
    endif
    print*
    
    deallocate(h_a)
  
  end subroutine ping_dev_ptr_2_host_targ  
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  subroutine ping_h_ptr_2_dev_targ()
    integer, dimension(:), pointer :: h_ptr_b
    
    integer :: send, receive

    print '(a)', 'ping_h_ptr_2_dev_targ:'
    
    ! allocate the host array, and point it to a device array
    allocate(d_b(n), stat=ierr)
    if (ierr /= 0) stop 'host allocation failed for d_b'
    print '(a)', 'OK: host can allocate a device array'
    
    h_ptr_b => d_b
    print '(a)', 'OK: host pointer can point at a device array'

    send = 2
    receive = 0
    d_b = send           ! copy data to device
    receive = h_ptr_b(1) ! fetch data from the host pointer
    
    if (send == receive) then 
       print '(a)', 'OK: host pointer can read/write to device target'
    else
       print '(a)', 'Failed: host pointer cannot read/write to device target'
    endif
    print *
    
    deallocate(d_b)
  
  end subroutine ping_h_ptr_2_dev_targ

  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  subroutine ping_2_managed_data()
    integer, dimension(:), allocatable, managed :: h_mng_c
    
    integer :: send, receive

    print '(a)', 'ping_to_managed_data:'
    
    print '(a)', 'Test 1: managed data on host'
    allocate(h_mng_c(n), stat=ierr)
    ierr = cudaMallocManaged(h_mng_c, n, cudaMemAttachGlobal)
    if (ierr /= 0) stop 'host failed to allocate managed array'
    print '(a)', 'OK: host can allocate managed data array'
    
    send = 3
    receive = 0
    call device_sets_on_device<<<1,1>>>(h_mng_c, send)
    call device_gets_from_device<<<1,1>>>(h_mng_c, receive)
    
    if (send == receive) then 
        print '(a)', 'OK: host can send and receive a managed data on device'
    else 
        print '(a)', 'Failed: host cannot send and receive a managed data on device'
    endif
    
    print '(a)', 'Test 2: managed data on device: d_mng_c'
    
    send = 4
    receive = 0
    call allocate_
    print*
  
  end subroutine ping_2_managed_data
  
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  subroutine ping_dev_tex_2_dev_targ()
    
  end subroutine ping_dev_tex_2_dev_targ
    
  !%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

end module host




program exper_1
  use dev
  use host
  
  implicit none
  
  integer, dimension(:), pointer :: h_ptr_a => null()

  integer, dimension(:), allocatable, device, target :: d_t
  integer, dimension(:), allocatable :: host_arr

  print*
  print '(a)', 'Note: below, the symbol "X=>Y" means pointer X points at array Y.'
  print*
  ! Can device pointer point at a host target?
  call ping_dev_ptr_2_host_targ()
  
  ! Can host pointer point at a device target?
  call ping_h_ptr_2_dev_targ()
 
  ! Can host and device arrays read/write to a managed memory?
  call ping_2_managed_data()

  ! Can  
  call ping_dev_tex_2_dev_targ()
    
end program exper_1
